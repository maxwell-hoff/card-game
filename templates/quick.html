{% extends 'base.html' %}
{% block content %}
  <h2>Quick Play</h2>

  {% if require_login %}
    <p>You must sign in to play. Use the "Sign in with Google" button in the top-right.</p>
  {% else %}
    {% if not puzzle %}
      <form method="get" action="/quick" id="quick-start-form">
        <label for="players">Players:</label>
        <input id="players" name="players" type="number" min="1" max="5" value="{{ players_count }}" />
        <label for="turns" style="margin-left:8px;">Turns:</label>
        <input id="turns" name="turns" type="number" min="1" value="{{ turns_filter if turns_filter is not none else '' }}" placeholder="Random" />
        <input type="hidden" name="go" value="1" />
        <button id="go-top-btn" type="submit">Go</button>
      </form>

      <div style="margin-top:12px; padding:8px; background:#f7f7f7; border:1px solid #ddd; border-radius:4px; max-width:520px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div>
            <strong>Players:</strong> <span id="players-count">{{ players_count }}</span>
          </div>
          <div>
            <button id="invite-add-btn" title="Invite by user ID code" style="padding:4px 8px;">+ Invite</button>
          </div>
        </div>
        <div id="party-list" style="margin-top:8px;">
          {% if party and party|length > 1 %}
            <ul id="party-ul" style="margin:0; padding-left:18px;"></ul>
          {% else %}
            <!-- <p style="margin:6px 0 0 0;">Only you for now. Invite teammates with the button above.</p> -->
          {% endif %}
        </div>
        <div id="lobby-controls" style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <button id="ready-toggle" style="padding:4px 8px;">Ready</button>
          <span id="lobby-status" style="color:#555;"></span>
        </div>
        <div id="invite-msg" style="margin-top:6px; color:#333;"></div>
      </div>

      {% if active_sessions and active_sessions|length > 0 %}
        <h3 style="margin-top:18px;">Resume a puzzle</h3>
        <table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse; min-width: 520px;">
          <thead>
            <tr>
              <th align="left">Puzzle ID</th>
              <th align="left">Players</th>
              <th align="left">Others</th>
              <th align="left">Expected Turns</th>
              <th align="left">Started</th>
              <th align="left">Action</th>
            </tr>
          </thead>
          <tbody>
            {% for s in active_sessions %}
              <tr>
                <td>{{ s.puzzle_id }}</td>
                <td>{{ s.players_count }}</td>
                <td>{% if s.others and s.others|length > 0 %}{{ s.others|join(', ') }}{% else %}-{% endif %}</td>
                <td>{{ s.expected_turns }}</td>
                <td>{{ s.started_at }}</td>
                <td><a href="/quick?session_id={{ s.session_id }}">Resume</a></td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      {% endif %}
    {% endif %}

    {% if not requested %}
      <!-- <p>Choose filters and hit Go to get a puzzle.</p> -->
    {% elif not puzzle %}
      <p>No puzzles found. Generate them first.</p>
    {% else %}
      <p><a href="/quick">← Back</a></p>
      <p><strong>Puzzle ID:</strong> {{ puzzle.id }} | <strong>Players:</strong> {{ puzzle.players }} | <strong>Level:</strong> {{ puzzle.level }}</p>
      <p><strong>Turns to solve in:</strong> {{ expected_turns }}{% if solve_pct is not none %} | <strong>Solve%:</strong> {{ '%.1f'|format(solve_pct) }}%{% endif %}</p>
      <div class="grid" id="static-grid" style="display:none;">
        {% set rows = layout.rows %}
        {% set row_res = layout.row_reserves %}
        {% set col_res = layout.col_reserves %}
        {% set opp = layout.opponent_row_index %}
        
        <!-- Column reserves (Bottom) shown at top with tooltip -->
        <div class="row">
          <div class="cell reserve" title="Column reserve bottom">&nbsp;</div>
          <div class="cell reserve" title="Column reserve bottom">&nbsp;</div>
          {% for c in range(5) %}
            <div class="cell reserve" title="Column reserve bottom">{{ col_res[c][1] }}</div>
          {% endfor %}
        </div>
        
        <!-- Column reserves (Top) shown at top with tooltip -->
        <div class="row">
          <div class="cell reserve" title="Column reserve top">&nbsp;</div>
          <div class="cell reserve" title="Column reserve top">&nbsp;</div>
          {% for c in range(5) %}
            <div class="cell reserve" title="Column reserve top">{{ col_res[c][0] }}</div>
          {% endfor %}
        </div>


        {% for r in range(rows|length) %}
          <div class="row">
            <div class="cell reserve" title="Row reserve bottom">{{ row_res[r][1] }}</div>
            <div class="cell reserve" title="Row reserve top">{{ row_res[r][0] }}</div>
            {% for c in range(5) %}
              <div class="cell {% if r==opp %}opponent{% endif %}">{{ rows[r][c] }}</div>
            {% endfor %}
          </div>
        {% endfor %}
      </div>

      <div id="interactive-play" style="margin-top:8px;"></div>

      <form method="post" action="/report" id="report-form">
        <input type="hidden" name="puzzle_id" value="{{ puzzle.id }}" />
        {% if session_id %}<input type="hidden" name="session_id" value="{{ session_id }}" />{% endif %}
        {% if turns_filter %}<input type="hidden" name="turns_filter" value="{{ turns_filter }}" />{% endif %}
        <input type="hidden" name="seconds" value="" />
        <label>
          <input type="checkbox" name="solved" value="1" /> Solved
        </label>
        <button type="submit">Submit</button>
      </form>
      {% if session_id %}
      <div style="margin-top:8px;">
        <button id="quick-give-up-btn" style="padding:4px 8px; background:#f7e0e0; border:1px solid #e0b0b0; border-radius:4px;">Give Up</button>
      </div>
      <!-- Solution steps modal -->
      <div id="quick-solution-modal" style="display:none; position:fixed; left:0; top:0; right:0; bottom:0; background: rgba(0,0,0,0.4); z-index: 9999;">
        <div style="background:#fff; width: 520px; max-width: 95vw; margin: 8% auto; padding: 16px; border-radius: 6px; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
            <h3 style="margin:0;">Solution</h3>
            <button id="quick-solution-modal-close" style="padding:4px 8px;">Close</button>
          </div>
          <div id="quick-solution-initial" style="margin-bottom:10px;"></div>
          <div id="quick-solution-steps">
            <p>Loading steps…</p>
          </div>
        </div>
      </div>
      {% endif %}
    {% endif %}
  {% endif %}
  <script type="module">
    // Poll session status to exit when anyone ends the session
    (function sessionStatusPolling(){
      const sessionIdInput = document.querySelector('input[name="session_id"]');
      const sid = sessionIdInput ? Number(sessionIdInput.value) : null;
      if (!sid) return;
      let timer = null;
      async function poll() {
        try {
          const r = await fetch(`/api/game_session/status?session_id=${sid}`);
          const j = await r.json().catch(() => null);
          if (j && j.ok) {
            const paused = window.__SESSION_POLL_PAUSED__ === true;
            if (j.status === 'completed' && !paused) {
              // Return to quick lobby
              location.href = '/quick';
              return;
            }
          }
        } catch (_) {}
        timer = setTimeout(poll, 3000);
      }
      poll();
      window.addEventListener('beforeunload', () => { if (timer) clearTimeout(timer); });
    })();
    // Define a global to refresh party after accepting invite from header
    window.refreshParty = async function refreshParty() {
      try {
        const r = await fetch('/api/party?mode=quick');
        if (!r.ok) return;
        const j = await r.json();
        if (!j || !j.ok) return;
        const party = j.party || [];
        const playersCountEl = document.getElementById('players-count');
        const list = document.getElementById('party-list');
        if (playersCountEl) playersCountEl.textContent = String(j.players_count || (1 + party.length));
        if (list) {
          if (party.length <= 1) {
            // list.innerHTML = '<p style="margin:6px 0 0 0;">Only you for now. Invite teammates with the button above.</p>';
            list.innerHTML = '';
          } else {
            const ul = document.createElement('ul');
            ul.id = 'party-ul';
            ul.style.margin = '0';
            ul.style.paddingLeft = '18px';
            list.innerHTML = '';
            list.appendChild(ul);
          }
        }
      } catch (_) {}
    };

    // Lobby polling for readiness/state
    (function initLobbyPolling() {
      const readyBtn = document.getElementById('ready-toggle');
      const goTopBtn = document.getElementById('go-top-btn');
      const lobbyStatus = document.getElementById('lobby-status');
      let isReady = false;
      let pollTimer = null;

      function renderReadyPills(party) {
        const pills = document.querySelectorAll('.ready-pill');
        pills.forEach((pill) => {
          const attr = pill.getAttribute('data-user');
          const uid = attr === 'self' ? window.__SESSION_USER_ID__ : attr;
          const matching = party.find(p => String(p.user_id) === String(uid));
          const ready = matching ? !!matching.ready : false;
          pill.textContent = ready ? '✓ ready' : 'not ready';
          pill.style.fontSize = '90%';
          pill.style.color = ready ? '#0a0' : '#a00';
          pill.style.marginLeft = '6px';
        });
      }

      function renderParty(party) {
        let ul = document.getElementById('party-ul');
        if (party.length <= 1) { if (ul) ul.innerHTML = ''; return; }
        if (!ul) {
          const list = document.getElementById('party-list');
          if (!list) return;
          ul = document.createElement('ul');
          ul.id = 'party-ul';
          ul.style.margin = '0';
          ul.style.paddingLeft = '18px';
          list.innerHTML = '';
          list.appendChild(ul);
        }
        ul.innerHTML = '';
        party.forEach((m) => {
          const li = document.createElement('li');
          const nameSpan = document.createElement('span');
          nameSpan.textContent = m.display_name + ' ';
          li.appendChild(nameSpan);
          const pill = document.createElement('span');
          pill.className = 'ready-pill';
          pill.setAttribute('data-user', String(m.user_id));
          li.appendChild(pill);
          // Host can kick others
          const myId = window.__SESSION_USER_ID__;
          if (party.length > 1 && myId && m.user_id !== myId) {
            // Determine host: first element in party is host in our API
            const hostId = party[0]?.user_id;
            if (myId === hostId) {
              const btn = document.createElement('button');
              btn.textContent = '−';
              btn.title = 'Remove from lobby';
              btn.style.marginLeft = '8px';
              btn.style.padding = '0 6px';
              btn.addEventListener('click', async (e) => {
                e.preventDefault();
                if (!confirm(`Remove ${m.display_name} from the lobby?`)) return;
                try {
                  const r = await fetch('/api/lobby/kick', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode: 'quick', user_id: m.user_id }) });
                  const j = await r.json().catch(() => null);
                  if (j && j.ok) fetchStatus();
                } catch (_) {}
              });
              li.appendChild(btn);
            }
          }
          // Invitees can leave
          if (party.length > 1 && myId && m.user_id === myId && myId !== party[0]?.user_id) {
            const leaveBtn = document.createElement('button');
            leaveBtn.textContent = 'Leave';
            leaveBtn.style.marginLeft = '8px';
            leaveBtn.addEventListener('click', async (e) => {
              e.preventDefault();
              try {
                const r = await fetch('/api/lobby/leave', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode: 'quick' }) });
                const j = await r.json().catch(() => null);
                if (j && j.ok) {
                  // Refresh UI after leaving; host view will auto-update as well
                  location.href = '/quick';
                }
              } catch (_) {}
            });
            li.appendChild(leaveBtn);
          }
          ul.appendChild(li);
        });
      }

      async function fetchStatus() {
        try {
          const r = await fetch('/api/lobby/status?mode=quick');
          const j = await r.json().catch(() => null);
          if (!j || !j.ok) return;
          const party = Array.isArray(j.party) ? j.party : [];
          // Hide ready UI when solo
          const controls = document.getElementById('lobby-controls');
          if (controls) controls.style.display = (party.length <= 1) ? 'none' : 'flex';
          renderParty(party);
          if (party.length > 1) renderReadyPills(party);
          if (lobbyStatus) lobbyStatus.textContent = (party.length <= 1) ? '' : (j.can_start ? 'All ready.' : 'Waiting for players…');
          const inviteMsg = document.getElementById('invite-msg');
          if (inviteMsg && party.length > 1) inviteMsg.textContent = '';
          // Toggle top Go button enabled state
          if (goTopBtn) {
            const disable = !(j && j.can_start);
            goTopBtn.disabled = disable;
            goTopBtn.style.opacity = disable ? '0.6' : '';
            goTopBtn.style.cursor = disable ? 'not-allowed' : '';
            goTopBtn.title = disable ? 'All players must be ready' : '';
          }
          // If a session exists for this lobby, redirect everyone to it
          const currentSessionInput = document.querySelector('input[name="session_id"]');
          const currentSessionId = currentSessionInput ? Number(currentSessionInput.value) : null;
          if (j.active_session_id && (!currentSessionId || Number(j.active_session_id) !== currentSessionId)) {
            location.href = '/quick?session_id=' + String(j.active_session_id);
            return;
          }
        } catch (_) {}
        finally {
          pollTimer = setTimeout(fetchStatus, 3000);
        }
      }

      async function setReadyState(flag) {
        try {
          await fetch('/api/lobby/ready', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode: 'quick', ready: !!flag }) });
        } catch (_) {}
      }

      // Ensure default is unready on load and when returning via back/forward cache
      setReadyState(false);
      window.addEventListener('pageshow', () => { setReadyState(false); });

      if (readyBtn) {
        readyBtn.addEventListener('click', async () => {
          isReady = !isReady;
          readyBtn.textContent = isReady ? 'Unready' : 'Ready';
          setReadyState(isReady);
          fetchStatus();
        });
      }
      // Intercept top Go submit to start via lobby API when multi-player
      if (goTopBtn) {
        const form = goTopBtn.closest('form');
        if (form) {
          form.addEventListener('submit', async (e) => {
            // Attempt to use lobby/start to unify session when in a party
            try {
              const r = await fetch('/api/lobby/status?mode=quick');
              const j = await r.json().catch(() => null);
              const partyLen = (j && j.ok && Array.isArray(j.party)) ? j.party.length : 1;
              if (partyLen > 1) {
                e.preventDefault();
                const rs = await fetch('/api/lobby/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode: 'quick' }) });
                const sr = await rs.json().catch(() => null);
                if (sr && sr.ok && sr.redirect_url) {
                  location.href = sr.redirect_url;
                }
                return;
              }
            } catch (_) { /* fall through to normal submit */ }
          });
        }
      }
      fetchStatus();
    })();

    const inviteAddBtn = document.getElementById('invite-add-btn');
    const inviteMsg = document.getElementById('invite-msg');
    if (inviteAddBtn) {
      inviteAddBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        const code = prompt('Invite player by user ID code (e.g., ABC234):');
        if (!code) return;
        try {
          const r = await fetch('/api/invites/create', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ user_code: code, mode: 'quick' }) });
          const j = await r.json().catch(() => null);
          if (j && j.ok) {
            if (inviteMsg) {
              inviteMsg.textContent = 'Invite sent. Expires in 5 minutes.';
              setTimeout(() => { inviteMsg.textContent = ''; }, 5000);
            }
          } else {
            const err = j && j.error ? j.error : 'failed';
            if (inviteMsg) inviteMsg.textContent = 'Invite ' + err + '.';
          }
        } catch (_) {
          if (inviteMsg) inviteMsg.textContent = 'Network error sending invite.';
        }
      });
    }
  </script>
  <script type="module">
    // --- Interactive Play (Quick) ---
    (function initInteractivePlay(){
      const container = document.getElementById('interactive-play');
      const form = document.getElementById('report-form');
      if (!container || !form) return;
      // Ensure we have layout and solved_layout injected by server
      const start = JSON.parse('{{ layout | default({}) | tojson | safe }}');
      const solved = JSON.parse('{{ solved_layout | default({}) | tojson | safe }}');
      if (!start || !start.rows || !start.row_reserves || !start.col_reserves) return;

      // Timer tracking
      let startTs = Date.now();
      function setFormSeconds() {
        const secInput = form.querySelector('input[name="seconds"]');
        if (secInput) {
          const elapsed = Math.max(0, Math.round((Date.now() - startTs) / 1000));
          secInput.value = String(elapsed);
        }
      }
      form.addEventListener('submit', () => setFormSeconds());

      // Deep copy helpers
      function cloneLayout(L){
        return {
          rows: L.rows.map(r => r.slice()),
          row_reserves: L.row_reserves.map(rr => rr.slice()),
          col_reserves: L.col_reserves.map(cr => cr.slice()),
          opponent_row_index: Number(L.opponent_row_index || 0),
        };
      }
      function layoutsEqual(a,b){
        if (!a || !b) return false;
        if (a.opponent_row_index !== b.opponent_row_index) return false;
        const eq2 = (x,y) => x.length === y.length && x.every((v,i) => v === y[i]);
        const eq2d = (x,y) => x.length === y.length && x.every((row,i) => eq2(row, y[i]));
        return eq2d(a.rows,b.rows) && eq2d(a.row_reserves,b.row_reserves) && eq2d(a.col_reserves,b.col_reserves);
      }
      function isSolvedByCriteria(L){
        if (!L || !L.rows || !L.row_reserves || !L.col_reserves) return false;
        const numRows = L.rows.length; const numCols = 5;
        // 1) Any row same suit
        for (let r=0; r<numRows; r++){
          const suits = L.rows[r].map(code => String(code).slice(-1));
          if (suits.length === numCols && new Set(suits).size === 1) return true;
        }
        // 2) Any column strictly ascending or strictly descending by rank
        const rankOf = (code) => { const s=String(code); const rk=parseInt(s.slice(0, -1), 10); return isFinite(rk) ? rk : -999; };
        for (let c=0; c<numCols; c++){
          const ranks = Array.from({length:numRows}, (_,r)=>rankOf(L.rows[r][c]));
          const asc = ranks.every((v,i,arr)=> i===0 || arr[i-1] < v);
          const desc = ranks.every((v,i,arr)=> i===0 || arr[i-1] > v);
          if (asc || desc) return true;
        }
        // 3) Opponent highest lower than ALL CARDS in all other rows
        const opp = Number(L.opponent_row_index||0);
        const oppHigh = Math.max(...L.rows[opp].map(rankOf));
        for (let r=0; r<numRows; r++){
          if (r===opp) continue;
          for (let c=0; c<numCols; c++) {
            const rv = rankOf(L.rows[r][c]);
            if (!(oppHigh < rv)) return false;
          }
        }
        return true;
      }

      // State
      let current = cloneLayout(start);
      const history = [];
      const opp = current.opponent_row_index;
      const expectedTurns = Number(JSON.parse('{{ expected_turns | default(0) | tojson | safe }}'));

      // Actions
      function pushAction(type, params){ history.push({ type, params }); }
      function applyAction(act){
        const t = act.type; const p = act.params || {};
        if (t === 'row_right') return shiftRowRight(p.row_index);
        if (t === 'row_left') return shiftRowLeft(p.row_index);
        if (t === 'col_down') return shiftColDown(p.col_index);
        if (t === 'col_up') return shiftColUp(p.col_index);
        if (t === 'swap') return swapInRow(p.row_index, p.i, p.j);
      }
      function reset(){ current = cloneLayout(start); history.length = 0; render(); }

      // Low-level transforms (match Python semantics)
      function shiftRowRight(r){
        r = Number(r);
        const top = current.row_reserves[r][0];
        const bottom = current.row_reserves[r][1];
        const arr = current.rows[r];
        const rightmost = arr[arr.length - 1];
        for (let k = arr.length - 1; k >= 1; k--) arr[k] = arr[k - 1];
        arr[0] = top;
        current.row_reserves[r][0] = bottom;
        current.row_reserves[r][1] = rightmost;
      }
      function shiftRowLeft(r){
        r = Number(r);
        const top = current.row_reserves[r][0];
        const bottom = current.row_reserves[r][1];
        const arr = current.rows[r];
        const leftmost = arr[0];
        for (let k = 0; k < arr.length - 1; k++) arr[k] = arr[k + 1];
        arr[arr.length - 1] = bottom;
        current.row_reserves[r][0] = leftmost;
        current.row_reserves[r][1] = top;
      }
      function shiftColDown(c){
        c = Number(c);
        const top = current.col_reserves[c][0];
        const bottom = current.col_reserves[c][1];
        const bottommost = current.rows[current.rows.length - 1][c];
        for (let r = current.rows.length - 1; r >= 1; r--) current.rows[r][c] = current.rows[r - 1][c];
        current.rows[0][c] = top;
        current.col_reserves[c][0] = bottom;
        current.col_reserves[c][1] = bottommost;
      }
      function shiftColUp(c){
        c = Number(c);
        const top = current.col_reserves[c][0];
        const bottom = current.col_reserves[c][1];
        const topmost = current.rows[0][c];
        for (let r = 0; r < current.rows.length - 1; r++) current.rows[r][c] = current.rows[r + 1][c];
        current.rows[current.rows.length - 1][c] = bottom;
        current.col_reserves[c][0] = topmost;
        current.col_reserves[c][1] = top;
      }
      function swapInRow(r,i,j){
        r = Number(r); i = Number(i); j = Number(j);
        const arr = current.rows[r];
        const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
        // Mirror swap in opponent row
        const oppArr = current.rows[opp];
        const tmp2 = oppArr[i]; oppArr[i] = oppArr[j]; oppArr[j] = tmp2;
      }

      // UI elements
      const header = document.createElement('div');
      header.style.marginBottom = '6px';
      const moveSpan = document.createElement('span');
      const statusSpan = document.createElement('span'); statusSpan.style.marginLeft = '10px';
      const btnReset = document.createElement('button'); btnReset.textContent = 'Reset'; btnReset.style.marginLeft = '6px';
      header.appendChild(moveSpan); header.appendChild(statusSpan); header.appendChild(btnReset);
      container.appendChild(header);
      btnReset.addEventListener('click', (e) => { e.preventDefault(); reset(); });

      const outer = document.createElement('div'); outer.style.display = 'flex'; outer.style.alignItems = 'flex-start'; outer.style.gap = '8px';
      const grid = document.createElement('div'); grid.className = 'grid';
      outer.appendChild(grid);
      container.appendChild(outer);

      // Swap selection
      let selected = null; // {r,c}

      function render(){
        // Moves + status
        moveSpan.textContent = `Moves: ${history.length}${Number.isFinite(expectedTurns) ? ' / ' + expectedTurns : ''}`;
        const isSolved = layoutsEqual(current, solved);
      // Include actions for server validation
      let actionsInput = form.querySelector('input[name="actions"]');
      if (!actionsInput) { actionsInput = document.createElement('input'); actionsInput.type='hidden'; actionsInput.name='actions'; form.appendChild(actionsInput); }
      form.addEventListener('submit', () => { try { actionsInput.value = JSON.stringify(history); } catch(_) {} });
        statusSpan.textContent = isSolved ? 'Solved!' : '';
        try {
          const solvedCheckbox = form.querySelector('input[name="solved"]');
          if (solvedCheckbox) solvedCheckbox.checked = isSolved;
        } catch (_) {}

        // Determine eligible row for this turn (players are rows 1..N; 0 is opponent)
        const numPlayers = Math.max(0, current.rows.length - 1);
        const eligibleRow = numPlayers > 0 ? (1 + (history.length % numPlayers)) : null;

        // Rebuild grid
        grid.innerHTML = '';
        // Column controls (up) ABOVE reserves
        {
          const ctrlUp = document.createElement('div'); ctrlUp.className = 'row';
          let pad = document.createElement('div'); pad.className = 'cell reserve'; pad.innerHTML='&nbsp;'; ctrlUp.appendChild(pad);
          pad = document.createElement('div'); pad.className = 'cell reserve'; pad.innerHTML='&nbsp;'; ctrlUp.appendChild(pad);
          for (let c = 0; c < 5; c++) {
            const btn = document.createElement('button'); btn.textContent = '↑'; btn.style.width='100%'; btn.style.padding='4px 0';
            const wrap = document.createElement('div'); wrap.className = 'cell'; wrap.appendChild(btn);
            btn.addEventListener('click', (e) => { e.preventDefault(); pushAction('col_up', { col_index: c }); shiftColUp(c); render(); });
            ctrlUp.appendChild(wrap);
          }
          grid.appendChild(ctrlUp);
        }
        // Bottom reserves first row (displayed at top)
        {
          const row = document.createElement('div'); row.className = 'row';
          let cell = document.createElement('div'); cell.className = 'cell reserve'; cell.innerHTML='&nbsp;'; row.appendChild(cell);
          cell = document.createElement('div'); cell.className = 'cell reserve'; cell.innerHTML='&nbsp;'; row.appendChild(cell);
          for (let c = 0; c < 5; c++) { const d = document.createElement('div'); d.className = 'cell reserve'; d.textContent = String(current.col_reserves[c][1] || ''); row.appendChild(d); }
          grid.appendChild(row);
        }
        // Top reserves
        {
          const row = document.createElement('div'); row.className = 'row';
          let cell = document.createElement('div'); cell.className = 'cell reserve'; cell.innerHTML='&nbsp;'; row.appendChild(cell);
          cell = document.createElement('div'); cell.className = 'cell reserve'; cell.innerHTML='&nbsp;'; row.appendChild(cell);
          for (let c = 0; c < 5; c++) {
            const d = document.createElement('div'); d.className = 'cell reserve'; d.textContent = String(current.col_reserves[c][0] || ''); row.appendChild(d);
          }
          grid.appendChild(row);
        }

        // Main rows with per-row controls and swap clicks
        for (let r = 0; r < current.rows.length; r++) {
          const rowDiv = document.createElement('div'); rowDiv.className = 'row';
          // Row reserve bottom
          const resBot = document.createElement('div'); resBot.className = 'cell reserve'; resBot.textContent = String(current.row_reserves[r][1] || ''); rowDiv.appendChild(resBot);
          // Row reserve top
          const resTop = document.createElement('div'); resTop.className = 'cell reserve'; resTop.textContent = String(current.row_reserves[r][0] || ''); rowDiv.appendChild(resTop);
          // 5 grid cells
          for (let c = 0; c < 5; c++) {
            const d = document.createElement('div'); d.className = 'cell' + (r === opp ? ' opponent' : ''); d.textContent = String(current.rows[r][c] || '');
            // Swap click behavior only on player rows
            if (r !== opp && (eligibleRow === null || r === eligibleRow)) {
              d.style.cursor = 'pointer';
              d.addEventListener('click', (e) => {
                e.preventDefault();
                if (!selected) { selected = { r, c }; d.style.outline = '2px solid #06c'; return; }
                const { r: sr, c: sc } = selected;
                const prevEl = grid.querySelector('[data-sel="1"]'); if (prevEl) { prevEl.removeAttribute('data-sel'); prevEl.style.outline = ''; }
                selected = null;
                if (sr === r && sc !== c) { pushAction('swap', { row_index: r, i: sc, j: c }); swapInRow(r, sc, c); render(); }
              });
              d.addEventListener('mousedown', () => { d.setAttribute('data-sel','1'); });
            }
            rowDiv.appendChild(d);
          }
          // Row left/right controls
          const lrWrap = document.createElement('div'); lrWrap.className = 'cell'; lrWrap.style.padding='0 4px'; lrWrap.style.border='0';
          const leftBtn = document.createElement('button'); leftBtn.textContent = '←'; leftBtn.style.marginRight='4px';
          const rightBtn = document.createElement('button'); rightBtn.textContent = '→';
          leftBtn.addEventListener('click', (e) => { e.preventDefault(); pushAction('row_left', { row_index: r }); shiftRowLeft(r); render(); });
          rightBtn.addEventListener('click', (e) => { e.preventDefault(); pushAction('row_right', { row_index: r }); shiftRowRight(r); render(); });
          // Disable on opponent row
          if (r === opp || (eligibleRow !== null && r !== eligibleRow)) { leftBtn.disabled = true; rightBtn.disabled = true; leftBtn.style.opacity='0.6'; rightBtn.style.opacity='0.6'; }
          lrWrap.appendChild(leftBtn); lrWrap.appendChild(rightBtn);
          rowDiv.appendChild(lrWrap);
          grid.appendChild(rowDiv);
        }
        // Column controls (down)
        const ctrlDown = document.createElement('div'); ctrlDown.className = 'row';
        let pad2 = document.createElement('div'); pad2.className = 'cell reserve'; pad2.innerHTML='&nbsp;'; ctrlDown.appendChild(pad2);
        pad2 = document.createElement('div'); pad2.className = 'cell reserve'; pad2.innerHTML='&nbsp;'; ctrlDown.appendChild(pad2);
        for (let c = 0; c < 5; c++) {
          const btn = document.createElement('button'); btn.textContent = '↓'; btn.style.width='100%'; btn.style.padding='4px 0';
          const wrap = document.createElement('div'); wrap.className = 'cell'; wrap.appendChild(btn);
          btn.addEventListener('click', (e) => { e.preventDefault(); pushAction('col_down', { col_index: c }); shiftColDown(c); render(); });
          ctrlDown.appendChild(wrap);
        }
        grid.appendChild(ctrlDown);
      }

      render();
    })();

    const quickGiveUpBtn = document.getElementById('quick-give-up-btn');
    const quickSolutionModal = document.getElementById('quick-solution-modal');
    const quickSolutionSteps = document.getElementById('quick-solution-steps');
    const quickSolutionInitial = document.getElementById('quick-solution-initial');
    const quickSolutionModalClose = document.getElementById('quick-solution-modal-close');
    if (quickSolutionModalClose && quickSolutionModal) {
      quickSolutionModalClose.addEventListener('click', () => {
        quickSolutionModal.style.display = 'none';
        try { window.__SESSION_POLL_PAUSED__ = false; } catch (_) {}
        location.href = '/quick';
      });
    }
    if (quickGiveUpBtn) {
      quickGiveUpBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        if (!confirm('Give up and end this quick play puzzle?')) return;
        try {
          const sessionIdInput = document.querySelector('input[name="session_id"]');
          const sessionId = sessionIdInput ? Number(sessionIdInput.value) : null;
          if (!sessionId) return;
          if (quickSolutionSteps) quickSolutionSteps.innerHTML = '<p>Loading steps…</p>';
          const r = await fetch('/quick/give_up', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ session_id: sessionId }) });
          const j = await r.json().catch(() => null);
          if (j && j.ok) {
            const steps = Array.isArray(j.steps) ? j.steps : [];
            const layout = j.layout || null;
            if (quickSolutionInitial) {
              if (layout && layout.rows && layout.row_reserves && layout.col_reserves) {
                // Render initial layout using same grid markup
                const rows = layout.rows;
                const row_res = layout.row_reserves;
                const col_res = layout.col_reserves;
                const opp = layout.opponent_row_index;
                const container = document.createElement('div');
                const title = document.createElement('div');
                title.innerHTML = '<strong>Initial Setup</strong>';
                title.style.marginBottom = '6px';
                container.appendChild(title);
                const grid = document.createElement('div');
                grid.className = 'grid';
                function makeRow(cells) {
                  const row = document.createElement('div');
                  row.className = 'row';
                  cells.forEach((html) => {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.innerHTML = html;
                    row.appendChild(cell);
                  });
                  return row;
                }
                // Bottom reserves row displayed first (matches page)
                {
                  const cells = ['&nbsp;','&nbsp;'];
                  for (let c = 0; c < 5; c++) cells.push(String(col_res[c][1] || ''));
                  grid.appendChild(makeRow(cells));
                }
                // Top reserves row
                {
                  const cells = ['&nbsp;','&nbsp;'];
                  for (let c = 0; c < 5; c++) cells.push(String(col_res[c][0] || ''));
                  grid.appendChild(makeRow(cells));
                }
                // Main rows
                for (let r = 0; r < rows.length; r++) {
                  const rowDiv = document.createElement('div');
                  rowDiv.className = 'row';
                  // prepend two reserve cells
                  const resBot = document.createElement('div'); resBot.className = 'cell reserve'; resBot.textContent = String(row_res[r][1] || '');
                  const resTop = document.createElement('div'); resTop.className = 'cell reserve'; resTop.textContent = String(row_res[r][0] || '');
                  rowDiv.appendChild(resBot);
                  rowDiv.appendChild(resTop);
                  for (let cc = 0; cc < 5; cc++) {
                    const gc = document.createElement('div');
                    gc.className = 'cell' + (r === opp ? ' opponent' : '');
                    gc.textContent = String(rows[r][cc] || '');
                    rowDiv.appendChild(gc);
                  }
                  grid.appendChild(rowDiv);
                }
                quickSolutionInitial.innerHTML = '';
                quickSolutionInitial.appendChild(title);
                quickSolutionInitial.appendChild(grid);
              } else {
                quickSolutionInitial.innerHTML = '';
              }
            }
            if (quickSolutionSteps) {
              if (steps.length > 0) {
                const ol = document.createElement('ol');
                steps.forEach((s) => {
                  const li = document.createElement('li');
                  li.textContent = s;
                  ol.appendChild(li);
                });
                quickSolutionSteps.innerHTML = '';
                quickSolutionSteps.appendChild(ol);
              } else {
                quickSolutionSteps.innerHTML = '<p>No steps available.</p>';
              }
            }
            if (quickSolutionModal) {
              window.__SESSION_POLL_PAUSED__ = true;
              quickSolutionModal.style.display = 'block';
            }
          } else {
            alert('Failed to give up.');
          }
        } catch (_) {
          alert('Network error.');
        }
      });
    }
  </script>
{% endblock %}
