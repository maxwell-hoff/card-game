{% extends 'base.html' %}
{% block content %}
  {% if require_login %}
    <p>You must sign in to play. Use the "Sign in with Google" button in the top-right.</p>
  {% else %}
    
    {% if not puzzle %}
      {% set has_active = active_sessions and active_sessions|length > 0 %}
      <form method="get" action="/play" id="play-start-form">
        <label for="players">Players:</label>
        <input id="players" name="players" type="number" min="1" max="5" value="{{ players_count }}" />
        <input type="hidden" name="go" value="1" />
        <button id="go-top-btn" class="btn btn-primary" type="submit" {% if has_active %}disabled title="You have an active game. Complete or give up first."{% endif %}>Play</button>
      </form>
      {% if has_active %}
        <div style="margin-top:6px; color:#666; font-size: 90%;">Complete your current game to start a new one.</div>
      {% endif %}

      <div class="card" style="margin-top:12px; max-width:520px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div>
            <strong>Players:</strong> <span id="players-count">{{ players_count }}</span>
          </div>
          <div>
            <button id="invite-add-btn" class="btn btn-primary" title="Invite by user ID code">+ Invite</button>
          </div>
        </div>
        <div id="party-list" style="margin-top:8px;">
          {% if party and party|length > 1 %}
            <ul id="party-ul"></ul>
          {% endif %}
        </div>
        <div id="lobby-controls" style="margin-top:8px; display:flex; gap:8px; align-items:center;">
          <button id="ready-toggle" class="btn">Ready</button>
          <span id="lobby-status" class="muted"></span>
        </div>
        <div id="invite-msg" style="margin-top:6px;"></div>
      </div>

      {% if active_sessions and active_sessions|length > 0 %}
        <h3 style="margin-top:18px;">Resume your game</h3>
        <table>
          <thead>
            <tr>
              <th align="left">Puzzle ID</th>
              <th align="left">Players</th>
              <th align="left">Others</th>
              <th align="left">Expected Turns</th>
              <th align="left">Started</th>
              <th align="left">Action</th>
            </tr>
          </thead>
          <tbody>
            {% for s in active_sessions %}
              <tr>
                <td>{{ s.puzzle_id }}</td>
                <td>{{ s.players_count }}</td>
                <td>{% if s.others and s.others|length > 0 %}{{ s.others|join(', ') }}{% else %}-{% endif %}</td>
                <td>{{ s.expected_turns }}</td>
                <td>{{ s.started_at }}</td>
                <td><a href="/play?session_id={{ s.session_id }}">Resume</a></td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      {% endif %}
    {% endif %}

    {% if requested and puzzle %}
      {% if session_id %}
      <div style="margin-bottom:8px;">
        <button id="give-up-btn" class="btn btn-danger">Give Up</button>
      </div>
      {% endif %}
      <div id="interactive-play" style="margin-top:0;"></div>
      <p style="margin-top:8px;"><strong>ELO:</strong> {% if elo is not none %}{{ '%.0f'|format(elo) }}{% else %}-{% endif %}</p>
      {% if host_id is defined and puzzle.players > 1 %}
        <div class="muted" style="margin-top:4px;">
          Host: {{ host_id }}{% if is_host %} (you){% endif %}
        </div>
      {% endif %}
      <p><strong>Puzzle ID:</strong> {{ puzzle.id }} | <strong>Players:</strong> {{ puzzle.players }} | <strong>Level:</strong> {{ puzzle.level }}</p>
      <div class="grid" id="static-grid" style="display:none;">
        {% set rows = layout.rows %}
        {% set row_res = layout.row_reserves %}
        {% set col_res = layout.col_reserves %}
        {% set opp = layout.opponent_row_index %}

        <div class="row">
          <div class="cell reserve empty" title="Column reserve bottom"></div>
          <div class="cell reserve empty" title="Column reserve bottom"></div>
          {% for c in range(5) %}
            <div class="cell reserve" title="Column reserve bottom">{{ col_res[c][1] }}</div>
          {% endfor %}
        </div>

        <div class="row">
          <div class="cell reserve empty" title="Column reserve top"></div>
          <div class="cell reserve empty" title="Column reserve top"></div>
          {% for c in range(5) %}
            <div class="cell reserve" title="Column reserve top">{{ col_res[c][0] }}</div>
          {% endfor %}
        </div>

        {% for r in range(rows|length) %}
          <div class="row">
            <div class="cell reserve" title="Row reserve bottom">{{ row_res[r][1] }}</div>
            <div class="cell reserve" title="Row reserve top">{{ row_res[r][0] }}</div>
            {% for c in range(5) %}
              <div class="cell {% if r==opp %}opponent{% endif %}">{{ rows[r][c] }}</div>
            {% endfor %}
          </div>
        {% endfor %}
      </div>

      

      <form method="post" action="/report" style="margin-top:8px;" id="report-form">
        <input type="hidden" name="puzzle_id" value="{{ puzzle.id }}" />
        {% if session_id %}<input type="hidden" name="session_id" value="{{ session_id }}" />{% endif %}
        <input type="hidden" name="seconds" value="" />
        <input type="hidden" name="solved" value="0" />
        
      </form>

      {% if session_id %}
      <!-- Success modal -->
      <div id="success-modal" class="modal-overlay" style="display:none; z-index: 9999;">
        <div class="modal">
          <div class="modal-header">
            <h3 style="margin:0;">ðŸŽ‰ Congratulations!</h3>
            <button id="success-modal-close" class="btn">Close</button>
          </div>
          <p style="margin-top:8px;">You solved the puzzle! What would you like to do next?</p>
          <div style="display:flex; gap:8px; margin-top:8px; flex-wrap: wrap;">
            <button id="success-new-puzzle" class="btn btn-primary">New puzzle</button>
            <button id="success-try-again" class="btn">Try again</button>
          </div>
        </div>
      </div>
      <!-- Turn limit reached modal -->
      <div id="limit-modal" class="modal-overlay" style="display:none; z-index: 9999;">
        <div class="modal">
          <div class="modal-header">
            <h3 style="margin:0;">Turn limit reached</h3>
            <button id="limit-modal-close" class="btn">Close</button>
          </div>
          <p style="margin-top:8px;">You used all turns. Choose an option:</p>
          <div style="display:flex; gap:8px; margin-top:8px; flex-wrap: wrap;">
            <button id="limit-try-again" class="btn btn-primary">Try again</button>
            <button id="limit-new-puzzle" class="btn">New puzzle</button>
            <button id="limit-show-solution" class="btn">Show solution</button>
          </div>
        </div>
      </div>
      <!-- Give up choice modal -->
      <div id="giveup-choice-modal" class="modal-overlay" style="display:none; z-index: 9999;">
        <div class="modal">
          <div class="modal-header">
            <h3 style="margin:0;">Give up?</h3>
            <button id="giveup-choice-close" class="btn">Close</button>
          </div>
          <p style="margin-top:8px;">Do you want to try again (counts as a loss) or show the solution?</p>
          <div style="display:flex; gap:8px; margin-top:8px;">
            <button id="try-again-btn" class="btn btn-primary">Try again</button>
            <button id="show-solution-btn" class="btn">Show solution</button>
          </div>
        </div>
      </div>
      <!-- Solution modal -->
      <div id="solution-modal" class="modal-overlay" style="display:none; z-index: 9999;">
        <div class="modal">
          <div class="modal-header">
            <h3 style="margin:0;">Solution</h3>
            <button id="solution-modal-close" class="btn">Close</button>
          </div>
          <div id="solution-initial" style="margin-bottom:10px;"></div>
          <div id="solution-steps">
            <p>Loadingâ€¦</p>
          </div>
        </div>
      </div>
      {% endif %}
    {% elif requested and not puzzle %}
      <p>No suitable puzzle found. Try again later.</p>
      {% if note %}<p>{{ note }}</p>{% endif %}
    {% endif %}
  {% endif %}

  <script type="module">
    // --- Interactive Play ---
    (function initInteractivePlay(){
      const container = document.getElementById('interactive-play');
      const form = document.getElementById('report-form');
      if (!container || !form) return;
      const start = JSON.parse('{{ layout | default({}) | tojson | safe }}');
      const solved = JSON.parse('{{ solved_layout | default({}) | tojson | safe }}');
      if (!start || !start.rows || !start.row_reserves || !start.col_reserves) return;

      // Timer into form
      let startTs = Date.now();
      function setFormSeconds(){
        const sec = form.querySelector('input[name="seconds"]');
        if (sec) sec.value = String(Math.max(0, Math.round((Date.now() - startTs)/1000)));
      }
      form.addEventListener('submit', () => setFormSeconds());

      function cloneLayout(L){ return { rows: L.rows.map(r=>r.slice()), row_reserves: L.row_reserves.map(rr=>rr.slice()), col_reserves: L.col_reserves.map(cr=>cr.slice()), opponent_row_index: Number(L.opponent_row_index||0) }; }
      function eq(a,b){ const eq2=(x,y)=>x.length===y.length&&x.every((v,i)=>v===y[i]); const eq2d=(x,y)=>x.length===y.length&&x.every((row,i)=>eq2(row,y[i])); return eq2d(a.rows,b.rows)&&eq2d(a.row_reserves,b.row_reserves)&&eq2d(a.col_reserves,b.col_reserves)&&a.opponent_row_index===b.opponent_row_index; }
      function isSolvedByCriteria(L){
        if (!L || !L.rows || !L.row_reserves || !L.col_reserves) return false;
        const numRows = L.rows.length; const numCols = 5;
        const rankOf1 = (code) => {
          const s = String(code || '');
          const body = s.slice(0, -1).toUpperCase();
          if (!body) return -999;
          if (/^\d+$/.test(body)) return parseInt(body, 10);
          switch (body) {
            case 'A': return 14;
            case 'K': return 13;
            case 'Q': return 12;
            case 'J': return 11;
            case 'T': return 10;
            default: return -999;
          }
        };
        // Check ALL three conditions must be met
        // 1) Any row same suit
        let condition1 = false;
        for (let r=0; r<numRows; r++){
          const suits = L.rows[r].map(code => String(code).slice(-1));
          if (suits.length === numCols && new Set(suits).size === 1) {
            condition1 = true;
            break;
          }
        }
        if (!condition1) return false;
        
        // 2) Any column strictly ascending or strictly descending by rank
        let condition2 = false;
        for (let c=0; c<numCols; c++){
          const ranks = Array.from({length:numRows}, (_,r)=>rankOf1(L.rows[r][c]));
          const asc = ranks.every((v,i,arr)=> i===0 || arr[i-1] < v);
          const desc = ranks.every((v,i,arr)=> i===0 || arr[i-1] > v);
          if (asc || desc) {
            condition2 = true;
            break;
          }
        }
        if (!condition2) return false;
        
        // 3) Opponent highest lower than ALL CARDS in all other rows
        const opp = Number(L.opponent_row_index||0);
        const oppHigh = Math.max(...L.rows[opp].map(rankOf1));
        for (let r=0; r<numRows; r++){
          if (r===opp) continue;
          for (let c=0; c<numCols; c++) {
            const rv = rankOf1(L.rows[r][c]);
            if (!(oppHigh < rv)) return false;
          }
        }
        return true;
      }

      // Compute each win condition individually for UI checklist
      function computeWinConditions(L){
        const res = {
          sameSuitRow: { ok: false, rowIndex: null },
          monoColumn: { ok: false, colIndex: null, direction: null },
          oppLowest: { ok: false }
        };
        if (!L || !L.rows) return res;
        const numRows = L.rows.length; const numCols = 5;
        // Same-suit row
        for (let r=0; r<numRows; r++){
          const suits = L.rows[r].map(code => String(code).slice(-1));
          if (suits.length === numCols && new Set(suits).size === 1){ res.sameSuitRow.ok = true; res.sameSuitRow.rowIndex = r; break; }
        }
        // Monotonic column
        const rankOf = (code) => { const s=String(code); const rk=parseInt(s.slice(0, -1), 10); return isFinite(rk) ? rk : -999; };
        for (let c=0; c<numCols; c++){
          const ranks = Array.from({length:numRows}, (_,r)=>rankOf(L.rows[r][c]));
          const asc = ranks.every((v,i,arr)=> i===0 || arr[i-1] < v);
          const desc = ranks.every((v,i,arr)=> i===0 || arr[i-1] > v);
          if (asc || desc){ res.monoColumn.ok = true; res.monoColumn.colIndex = c; res.monoColumn.direction = asc ? 'asc' : 'desc'; break; }
        }
        // Opponent highest lower than all others
        const oppIdx = Number(L.opponent_row_index||0);
        if (Number.isInteger(oppIdx) && oppIdx >= 0 && oppIdx < numRows){
          const oppHigh = Math.max(...L.rows[oppIdx].map(rankOf));
          let allHigher = true;
          for (let r=0; r<numRows && allHigher; r++){
            if (r===oppIdx) continue;
            for (let c=0; c<numCols; c++){
              if (!(oppHigh < rankOf(L.rows[r][c]))){ allHigher = false; break; }
            }
          }
          res.oppLowest.ok = allHigher;
        }
        return res;
      }

      let current = cloneLayout(start);
      const history = [];
      const opp = current.opponent_row_index;
      const expectedTurns = Number(JSON.parse('{{ expected_turns | default(0) | tojson | safe }}'));
      // Track prior solved state to only auto-submit on transition to solved
      let prevDone = (function(){ try { return eq(current, solved) || isSolvedByCriteria(current); } catch(_) { return false; } })();
      let locked = false; // lock interactions when move limit reached or puzzle solved
      let prevLimit = false;

      // Helper function to check if move is allowed
      function canMakeMove() {
        if (locked) return false;
        const doneExact = eq(current, solved);
        const doneByCriteria = isSolvedByCriteria(current);
        const done = doneExact || doneByCriteria;
        if (done) return false;
        const limitReached = (Number.isFinite(expectedTurns) && expectedTurns > 0 && history.length >= expectedTurns);
        return !limitReached;
      }

      function push(type, params){ 
        if (!canMakeMove()) return false;
        history.push({type, params}); 
        return true;
      }
      function reset(){ /* disabled */ }

      function rowRight(r){ r=+r; const top=current.row_reserves[r][0], bottom=current.row_reserves[r][1]; const arr=current.rows[r]; const rightmost=arr[arr.length-1]; for(let k=arr.length-1;k>=1;k--) arr[k]=arr[k-1]; arr[0]=top; current.row_reserves[r][0]=bottom; current.row_reserves[r][1]=rightmost; }
      function rowLeft(r){ r=+r; const top=current.row_reserves[r][0], bottom=current.row_reserves[r][1]; const arr=current.rows[r]; const leftmost=arr[0]; for(let k=0;k<arr.length-1;k++) arr[k]=arr[k+1]; arr[arr.length-1]=bottom; current.row_reserves[r][0]=leftmost; current.row_reserves[r][1]=top; }
      function colDown(c){ c=+c; const top=current.col_reserves[c][0], bottom=current.col_reserves[c][1]; const bottommost=current.rows[current.rows.length-1][c]; for(let r=current.rows.length-1;r>=1;r--) current.rows[r][c]=current.rows[r-1][c]; current.rows[0][c]=top; current.col_reserves[c][0]=bottom; current.col_reserves[c][1]=bottommost; }
      function colUp(c){ c=+c; const top=current.col_reserves[c][0], bottom=current.col_reserves[c][1]; const topmost=current.rows[0][c]; for(let r=0;r<current.rows.length-1;r++) current.rows[r][c]=current.rows[r+1][c]; current.rows[current.rows.length-1][c]=bottom; current.col_reserves[c][0]=topmost; current.col_reserves[c][1]=top; }
      function swapR(r,i,j){ r=+r; i=+i; j=+j; const arr=current.rows[r]; const t=arr[i]; arr[i]=arr[j]; arr[j]=t; const o=current.rows[opp]; const t2=o[i]; o[i]=o[j]; o[j]=t2; }
      function apply(act){ const t=act.type, p=act.params||{}; if(t==='row_right') return rowRight(p.row_index); if(t==='row_left') return rowLeft(p.row_index); if(t==='col_down') return colDown(p.col_index); if(t==='col_up') return colUp(p.col_index); if(t==='swap') return swapR(p.row_index,p.i,p.j); }

      const header=document.createElement('div'); header.style.marginBottom='6px';
      const moveSpan=document.createElement('span'); const statusSpan=document.createElement('span'); statusSpan.style.marginLeft='10px';
      header.appendChild(moveSpan); header.appendChild(statusSpan);
      container.appendChild(header);

      // Win conditions checklist UI
      const winWrap = document.createElement('div');
      winWrap.style.margin = '6px 0 10px 0';
      const winTitle = document.createElement('div');
      winTitle.innerHTML = '<strong>Win conditions</strong>';
      const winList = document.createElement('ul');
      winList.id = 'win-conditions';
      winList.style.margin = '6px 0 0 0';
      winList.style.paddingLeft = '18px';
      winWrap.appendChild(winTitle);
      winWrap.appendChild(winList);
      container.appendChild(winWrap);

      const grid=document.createElement('div'); grid.className='grid'; container.appendChild(grid);
      let selected=null;

      function render(){
        moveSpan.textContent = `Moves: ${history.length}${Number.isFinite(expectedTurns) ? ' / ' + expectedTurns : ''}`;
        const doneExact = eq(current, solved);
        const doneByCriteria = isSolvedByCriteria(current);
        const done = doneExact || doneByCriteria;
        // Only show "Solved!" after at least one move to avoid initial solved flash
        statusSpan.textContent = (done && history.length > 0) ? 'Solved!' : '';
        try { const cb=form.querySelector('input[name="solved"]'); if (cb) cb.value = done ? '1' : '0'; } catch(_) {}

        // Update win conditions checklist from current layout
        const cond = computeWinConditions(current);
        const li = (label, ok) => `<li>${ok ? 'âœ…' : 'â¬œ'} ${label}</li>`;
        winList.innerHTML = [
          li('One row is all the same suit', cond.sameSuitRow.ok),
          li('One column strictly ascending or descending by rank', cond.monoColumn.ok),
          li("Opponent row's highest is lower than all other cards", cond.oppLowest.ok)
        ].join('');

        // Determine eligible row for this turn
        const numPlayers = Math.max(0, current.rows.length - 1);
        const eligibleRow = numPlayers > 0 ? (1 + (history.length % numPlayers)) : null;

        // Determine if current viewer is host; only host can act
        const HOST_ID = Number(JSON.parse('{{ host_id | default(None) | tojson | safe }}'));
        const MY_ID = Number(window.__SESSION_USER_ID__ || 0);
        const isHost = (HOST_ID && MY_ID && Number(HOST_ID) === Number(MY_ID));
        const limitReached = (!done && Number.isFinite(expectedTurns) && expectedTurns > 0 && history.length >= expectedTurns);
        locked = !!limitReached || !!done;

        grid.innerHTML='';
        // Column up controls ABOVE reserves
        { const row=document.createElement('div'); row.className='row';
          // Left control spacer
          let d=document.createElement('div'); d.className='cell empty'; row.appendChild(d);
          // Reserve column spacers
          d=document.createElement('div'); d.className='cell reserve empty'; row.appendChild(d);
          d=document.createElement('div'); d.className='cell reserve empty'; row.appendChild(d);
          // Column up controls above each playable column
          for(let c=0;c<5;c++){
            const btn=document.createElement('button'); btn.textContent='â†‘'; btn.style.width='100%'; btn.style.height='100%';
            const wrap=document.createElement('div'); wrap.className='cell'; wrap.appendChild(btn);
            btn.addEventListener('click', (e)=>{ e.preventDefault(); if (!isHost || !canMakeMove()) return; if (push('col_up',{col_index:c})) { colUp(c); render(); } });
            if (!isHost || locked) { btn.disabled = true; btn.style.opacity='0.6'; btn.style.cursor='not-allowed'; }
            row.appendChild(wrap);
          }
          // Right control spacer
          d=document.createElement('div'); d.className='cell empty'; row.appendChild(d);
          grid.appendChild(row);
        }
        // Bottom reserves row (top display)
        { const row=document.createElement('div'); row.className='row';
          // Left control spacer
          let d=document.createElement('div'); d.className='cell empty'; row.appendChild(d);
          // Reserve column spacers
          d=document.createElement('div'); d.className='cell reserve empty'; row.appendChild(d);
          d=document.createElement('div'); d.className='cell reserve empty'; row.appendChild(d);
          for(let c=0;c<5;c++){
            const x=document.createElement('div'); x.className='cell reserve'; x.textContent=String(current.col_reserves[c][1]||''); if (!x.textContent) x.classList.add('empty'); row.appendChild(x);
          }
          // Right control spacer
          d=document.createElement('div'); d.className='cell empty'; row.appendChild(d);
          grid.appendChild(row);
        }
        // Top reserves row
        { const row=document.createElement('div'); row.className='row';
          // Left control spacer
          let d=document.createElement('div'); d.className='cell empty'; row.appendChild(d);
          // Reserve column spacers
          d=document.createElement('div'); d.className='cell reserve empty'; row.appendChild(d);
          d=document.createElement('div'); d.className='cell reserve empty'; row.appendChild(d);
          for(let c=0;c<5;c++){
            const x=document.createElement('div'); x.className='cell reserve'; x.textContent=String(current.col_reserves[c][0]||''); if (!x.textContent) x.classList.add('empty'); row.appendChild(x);
          }
          // Right control spacer
          d=document.createElement('div'); d.className='cell empty'; row.appendChild(d);
          grid.appendChild(row);
        }
        // Rows
        for (let r=0; r<current.rows.length; r++) {
          const row=document.createElement('div'); row.className='row';

          // Left control at far left of row
          const leftWrap=document.createElement('div'); leftWrap.className='cell'; leftWrap.style.padding='0 4px';
          const btnLeft=document.createElement('button'); btnLeft.textContent='â†'; btnLeft.style.width='100%'; btnLeft.style.height='100%';
          btnLeft.addEventListener('click', (e)=>{ e.preventDefault(); if (!isHost || !canMakeMove()) return; if (push('row_left', { row_index:r })) { rowLeft(r); render(); } });
          leftWrap.appendChild(btnLeft); row.appendChild(leftWrap);

          // Row reserves
          let d=document.createElement('div'); d.className='cell reserve'; d.textContent=String(current.row_reserves[r][1]||''); row.appendChild(d);
          d=document.createElement('div'); d.className='cell reserve'; d.textContent=String(current.row_reserves[r][0]||''); row.appendChild(d);

          // Main cells
          for (let c=0; c<5; c++) {
            const cell=document.createElement('div'); cell.className='cell' + (r===opp ? ' opponent' : ''); cell.textContent=String(current.rows[r][c]||'');
            if (!locked && r !== opp && (eligibleRow === null || r === eligibleRow)) {
              cell.style.cursor='pointer';
              cell.addEventListener('click', (e)=>{
                e.preventDefault();
                if (!isHost || !canMakeMove()) return;
                if (!selected) { selected = { r, c }; cell.style.outline='2px solid #06c'; return; }
                const sr=selected.r, sc=selected.c; const prev=grid.querySelector('[data-sel=\"1\"]'); if (prev) { prev.removeAttribute('data-sel'); prev.style.outline=''; }
                selected = null;
                if (sr===r && sc!==c) { if (push('swap', { row_index:r, i:sc, j:c })) { swapR(r, sc, c); render(); } }
              });
              cell.addEventListener('mousedown', ()=>{ cell.setAttribute('data-sel','1'); });
            }
            row.appendChild(cell);
          }

          // Right control on far right
          const rightWrap=document.createElement('div'); rightWrap.className='cell'; rightWrap.style.padding='0 4px';
          const btnRight=document.createElement('button'); btnRight.textContent='â†’'; btnRight.style.width='100%'; btnRight.style.height='100%';
          btnRight.addEventListener('click', (e)=>{ e.preventDefault(); if (!isHost || !canMakeMove()) return; if (push('row_right', { row_index:r })) { rowRight(r); render(); } });
          rightWrap.appendChild(btnRight); row.appendChild(rightWrap);
          if (!isHost || locked || r===opp || (eligibleRow !== null && r !== eligibleRow)) { btnLeft.disabled=true; btnRight.disabled=true; btnLeft.style.opacity='0.6'; btnRight.style.opacity='0.6'; }

          grid.appendChild(row);
        }
        // Column down controls
        { const row=document.createElement('div'); row.className='row';
          // Left control spacer
          let d=document.createElement('div'); d.className='cell empty'; row.appendChild(d);
          // Reserve column spacers
          d=document.createElement('div'); d.className='cell reserve empty'; row.appendChild(d);
          d=document.createElement('div'); d.className='cell reserve empty'; row.appendChild(d);
          for(let c=0;c<5;c++){
            const btn=document.createElement('button'); btn.textContent='â†“'; btn.style.width='100%'; btn.style.height='100%';
            const wrap=document.createElement('div'); wrap.className='cell'; wrap.appendChild(btn);
            btn.addEventListener('click', (e)=>{ e.preventDefault(); if (!isHost || !canMakeMove()) return; if (push('col_down', { col_index:c })) { colDown(c); render(); } });
            if (!isHost || locked) { btn.disabled = true; btn.style.opacity='0.6'; btn.style.cursor='not-allowed'; }
            row.appendChild(wrap);
          }
          // Right control spacer
          d=document.createElement('div'); d.className='cell empty'; row.appendChild(d);
          grid.appendChild(row);
        }

        // Show success modal when puzzle is solved
        const transitionedToDone = (!prevDone && done);
        if (transitionedToDone && isHost && history.length > 0) {
          const successModal = document.getElementById('success-modal');
          if (successModal) successModal.style.display = 'block';
          // Auto-submit after showing modal
          try { 
            setTimeout(() => {
              try { form.submit(); } catch(_) {}
            }, 100);
          } catch(_) {}
        }
        prevDone = done;
        const transitionedToLimit = (!prevLimit && limitReached);
        prevLimit = limitReached;
        if (transitionedToLimit && limitReached && isHost) {
          const limitModal = document.getElementById('limit-modal');
          if (limitModal) limitModal.style.display = 'block';
        }
      }

      // Post action history for server validation
      let actionsInput = form.querySelector('input[name="actions"]');
      if (!actionsInput) { actionsInput = document.createElement('input'); actionsInput.type='hidden'; actionsInput.name='actions'; form.appendChild(actionsInput); }
      form.addEventListener('submit', () => { try { actionsInput.value = JSON.stringify(history); } catch(_) {} });

      render();

      // Hook up success modal actions
      (function initSuccessModal(){
        const successModal = document.getElementById('success-modal');
        if (!successModal) return;
        const closeBtn = document.getElementById('success-modal-close');
        const newPuzzleBtn = document.getElementById('success-new-puzzle');
        const tryAgainBtn = document.getElementById('success-try-again');
        if (closeBtn) closeBtn.addEventListener('click', () => { successModal.style.display = 'none'; });
        if (newPuzzleBtn) newPuzzleBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          try {
            const sessionIdInput = document.querySelector('input[name="session_id"]');
            const sessionId = sessionIdInput ? Number(sessionIdInput.value) : null;
            if (!sessionId) return;
            const r = await fetch('/play/new_puzzle', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ session_id: sessionId }) });
            const j = await r.json().catch(() => null);
            if (j && j.ok && j.redirect_url) { location.href = j.redirect_url; }
          } catch(_) {}
        });
        if (tryAgainBtn) tryAgainBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          try {
            const sessionIdInput = document.querySelector('input[name="session_id"]');
            const sessionId = sessionIdInput ? Number(sessionIdInput.value) : null;
            if (!sessionId) return;
            const r = await fetch('/play/try_again', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ session_id: sessionId }) });
            const j = await r.json().catch(() => null);
            if (j && j.ok && j.redirect_url) { location.href = j.redirect_url; }
          } catch(_) {}
        });
      })();

      // Hook up limit modal actions
      (function initLimitModal(){
        const limitModal = document.getElementById('limit-modal');
        if (!limitModal) return;
        const closeBtn = document.getElementById('limit-modal-close');
        const tryAgainBtn2 = document.getElementById('limit-try-again');
        const newPuzzleBtn = document.getElementById('limit-new-puzzle');
        const showSolBtn2 = document.getElementById('limit-show-solution');
        if (closeBtn) closeBtn.addEventListener('click', () => { limitModal.style.display = 'none'; });
        if (tryAgainBtn2) tryAgainBtn2.addEventListener('click', async (e) => {
          e.preventDefault();
          try {
            const sessionIdInput = document.querySelector('input[name="session_id"]');
            const sessionId = sessionIdInput ? Number(sessionIdInput.value) : null;
            if (!sessionId) return;
            const r = await fetch('/play/try_again', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ session_id: sessionId }) });
            const j = await r.json().catch(() => null);
            if (j && j.ok && j.redirect_url) { location.href = j.redirect_url; }
          } catch(_) {}
        });
        if (newPuzzleBtn) newPuzzleBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          try {
            const sessionIdInput = document.querySelector('input[name="session_id"]');
            const sessionId = sessionIdInput ? Number(sessionIdInput.value) : null;
            if (!sessionId) return;
            const r = await fetch('/play/new_puzzle', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ session_id: sessionId }) });
            const j = await r.json().catch(() => null);
            if (j && j.ok && j.redirect_url) { location.href = j.redirect_url; }
          } catch(_) {}
        });
        if (showSolBtn2) showSolBtn2.addEventListener('click', async (e) => {
          e.preventDefault();
          try {
            const sessionIdInput = document.querySelector('input[name="session_id"]');
            const sessionId = sessionIdInput ? Number(sessionIdInput.value) : null;
            if (!sessionId) return;
            const r = await fetch('/play/give_up', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ session_id: sessionId }) });
            const j = await r.json().catch(() => null);
            if (j && j.ok) {
              const solutionModal = document.getElementById('solution-modal');
              const stepsEl = document.getElementById('solution-steps');
              if (stepsEl) stepsEl.innerHTML = (Array.isArray(j.steps) ? j.steps.map(s => `<div>${String(s)}</div>`).join('') : '<p>No steps.</p>');
              if (solutionModal) solutionModal.style.display = 'block';
            }
          } catch(_) {}
        });
      })();
    })();

    // Poll session status so all players exit when any finishes
    (function sessionStatusPolling(){
      const sessionIdInput = document.querySelector('input[name="session_id"]');
      const sid = sessionIdInput ? Number(sessionIdInput.value) : null;
      if (!sid) return;
      let timer = null;
      async function poll() {
        try {
          const r = await fetch(`/api/game_session/status?session_id=${sid}`);
          const j = await r.json().catch(() => null);
          if (j && j.ok) {
            const paused = window.__SESSION_POLL_PAUSED__ === true;
            if (j.status === 'completed' && !paused) {
              location.href = '/play';
              return;
            }
          }
        } catch (_) {}
        timer = setTimeout(poll, 3000);
      }
      poll();
      window.addEventListener('beforeunload', () => { if (timer) clearTimeout(timer); });
    })();
    // Invite helpers
    window.refreshParty = async function refreshParty() {
      try {
        const r = await fetch('/api/party?mode=ranked');
        if (!r.ok) return;
        const j = await r.json();
        if (!j || !j.ok) return;
        const party = j.party || [];
        const list = document.getElementById('party-list');
        // Do not override selected players with party size; selection is independent
        if (list) {
          if (party.length <= 1) {
            list.innerHTML = '';
          } else {
            const ul = document.createElement('ul');
            ul.id = 'party-ul';
            ul.style.margin = '0';
            ul.style.paddingLeft = '18px';
            list.innerHTML = '';
            list.appendChild(ul);
          }
        }
      } catch (_) {}
    };

    // Lobby polling for readiness/state
    (function initLobbyPolling() {
      const readyBtn = document.getElementById('ready-toggle');
      const goTopBtn = document.getElementById('go-top-btn');
      const playersInput = document.getElementById('players');
      const playersCountSpan = document.getElementById('players-count');
      const lobbyStatus = document.getElementById('lobby-status');
      let isReady = false;
      let pollTimer = null;
      // Block auto-redirect briefly on back/forward navigations
      let redirectBlockUntilTs = 0;
      try {
        const navEntries = (performance && performance.getEntriesByType) ? performance.getEntriesByType('navigation') : null;
        const navType = navEntries && navEntries[0] ? navEntries[0].type : (performance && performance.navigation && performance.navigation.type === 2 ? 'back_forward' : '');
        const stored = parseInt((localStorage.getItem('lobbyRedirectBlockUntil') || '0'), 10) || 0;
        redirectBlockUntilTs = Math.max(stored, Number(window.__LOBBY_REDIRECT_BLOCKED_UNTIL__ || 0) || 0);
        const isBackForward = navType === 'back_forward';
        if (isBackForward) {
          redirectBlockUntilTs = Date.now() + 12000; // 12s grace
          window.__LOBBY_REDIRECT_BLOCKED_UNTIL__ = redirectBlockUntilTs;
          localStorage.setItem('lobbyRedirectBlockUntil', String(redirectBlockUntilTs));
          // Add noredirect=1 to URL to ensure no auto-redirect while user navigates back
          try {
            const url = new URL(location.href);
            url.searchParams.set('noredirect', '1');
            history.replaceState(history.state, '', url.toString());
          } catch(_) {}
        }
        window.addEventListener('pageshow', (e) => {
          if (e && e.persisted) {
            const ts = Date.now() + 12000;
            redirectBlockUntilTs = ts;
            window.__LOBBY_REDIRECT_BLOCKED_UNTIL__ = ts;
            try { localStorage.setItem('lobbyRedirectBlockUntil', String(ts)); } catch(_) {}
            try {
              const url = new URL(location.href);
              url.searchParams.set('noredirect', '1');
              history.replaceState(history.state, '', url.toString());
            } catch(_) {}
          }
        });
      } catch (_) {}

      function hasNoRedirectParam() {
        try { return new URLSearchParams(location.search).get('noredirect') === '1'; } catch(_) { return false; }
      }

      if (playersInput && playersCountSpan) {
        const sync = () => { const v = Math.max(1, Math.min(5, parseInt(playersInput.value || '1', 10) || 1)); playersCountSpan.textContent = String(v); };
        playersInput.addEventListener('input', sync);
        sync();
      }

      function renderReadyPills(party) {
        const pills = document.querySelectorAll('.ready-pill');
        pills.forEach((pill) => {
          const attr = pill.getAttribute('data-user');
          const uid = attr === 'self' ? window.__SESSION_USER_ID__ : attr;
          const matching = party.find(p => String(p.user_id) === String(uid));
          const ready = matching ? !!matching.ready : false;
          pill.textContent = ready ? 'âœ“ ready' : 'not ready';
          pill.style.fontSize = '90%';
          pill.style.color = ready ? '#0a0' : '#a00';
          pill.style.marginLeft = '6px';
        });
      }

      function renderParty(party) {
        let ul = document.getElementById('party-ul');
        if (party.length <= 1) { if (ul) ul.innerHTML=''; return; }
        if (!ul) {
          const list = document.getElementById('party-list');
          if (!list) return;
          ul = document.createElement('ul');
          ul.id = 'party-ul';
          ul.style.margin = '0';
          ul.style.paddingLeft = '18px';
          list.innerHTML = '';
          list.appendChild(ul);
        }
        ul.innerHTML = '';
        party.forEach((m) => {
          const li = document.createElement('li');
          const nameSpan = document.createElement('span');
          nameSpan.textContent = m.display_name + ' ';
          li.appendChild(nameSpan);
          const pill = document.createElement('span');
          pill.className = 'ready-pill pill';
          pill.setAttribute('data-user', String(m.user_id));
          li.appendChild(pill);
          const myId = window.__SESSION_USER_ID__;
          // Host can kick others
          if (party.length > 1 && myId && m.user_id !== myId) {
            const hostId = party[0]?.user_id;
            if (myId === hostId) {
              const btn = document.createElement('button');
              btn.textContent = 'âˆ’';
              btn.title = 'Remove from lobby';
              btn.style.marginLeft = '8px';
              btn.style.padding = '0 6px';
              btn.addEventListener('click', async (e) => {
                e.preventDefault();
                if (!confirm(`Remove ${m.display_name} from the lobby?`)) return;
                try {
                  const r = await fetch('/api/lobby/kick', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode: 'ranked', user_id: m.user_id }) });
                  const j = await r.json().catch(() => null);
                  if (j && j.ok) fetchStatus();
                } catch (_) {}
              });
              li.appendChild(btn);
            }
          }
          // Invitees can leave
          if (party.length > 1 && myId && m.user_id === myId && myId !== party[0]?.user_id) {
            const leaveBtn = document.createElement('button');
            leaveBtn.textContent = 'Leave';
            leaveBtn.style.marginLeft = '8px';
            leaveBtn.addEventListener('click', async (e) => {
              e.preventDefault();
              try {
                const r = await fetch('/api/lobby/leave', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode: 'ranked' }) });
                const j = await r.json().catch(() => null);
                if (j && j.ok) {
                  location.href = '/play';
                }
              } catch (_) {}
            });
            li.appendChild(leaveBtn);
          }
          ul.appendChild(li);
        });
      }

      async function fetchStatus() {
        try {
          const r = await fetch('/api/lobby/status?mode=ranked');
          const j = await r.json().catch(() => null);
          if (!j || !j.ok) return;
          const party = Array.isArray(j.party) ? j.party : [];
          // Hide ready UI when solo
          const controls = document.getElementById('lobby-controls');
          if (controls) controls.style.display = (party.length <= 1) ? 'none' : 'flex';
          renderParty(party);
          if (party.length > 1) renderReadyPills(party);
          if (lobbyStatus) lobbyStatus.textContent = (party.length <= 1) ? '' : (j.can_start ? 'All ready.' : 'Waiting for playersâ€¦');
          const inviteMsg = document.getElementById('invite-msg');
          if (inviteMsg && party.length > 1) inviteMsg.textContent = '';
          if (goTopBtn && !goTopBtn.hasAttribute('disabled')) {
            const disable = !(j && j.can_start);
            goTopBtn.disabled = disable;
            goTopBtn.style.opacity = disable ? '0.6' : '';
            goTopBtn.style.cursor = disable ? 'not-allowed' : '';
            goTopBtn.title = disable ? 'All players must be ready' : '';
          }
          // If a session exists for this lobby, redirect everyone to it
          const currentSessionInput = document.querySelector('input[name="session_id"]');
          const currentSessionId = currentSessionInput ? Number(currentSessionInput.value) : null;
          if (j.active_session_id && (!currentSessionId || Number(j.active_session_id) !== currentSessionId)) {
            const blockUntil = Math.max(
              Number(window.__LOBBY_REDIRECT_BLOCKED_UNTIL__ || 0),
              parseInt((localStorage.getItem('lobbyRedirectBlockUntil') || '0'), 10) || 0
            );
            const skipByParam = hasNoRedirectParam();
            if (!skipByParam && Date.now() >= blockUntil) {
              try { localStorage.removeItem('lobbyRedirectBlockUntil'); } catch(_) {}
              location.href = '/play?session_id=' + String(j.active_session_id);
              return;
            } else if (lobbyStatus) {
              const href = '/play?session_id=' + String(j.active_session_id);
              lobbyStatus.innerHTML = 'Session ready. <a href="' + href + '">Resume</a> (auto-redirect paused)';
            }
          }
        } catch (_) {}
        finally {
          pollTimer = setTimeout(fetchStatus, 3000);
        }
      }

      async function setReadyState(flag) {
        try {
          await fetch('/api/lobby/ready', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode: 'ranked', ready: !!flag }) });
        } catch (_) {}
      }

      // Ensure default is unready on load and when returning via back/forward cache
      setReadyState(false);
      window.addEventListener('pageshow', () => { setReadyState(false); });

      if (readyBtn) {
        readyBtn.addEventListener('click', async () => {
          isReady = !isReady;
          readyBtn.textContent = isReady ? 'Unready' : 'Ready';
          setReadyState(isReady);
          fetchStatus();
        });
      }
      // Intercept top Play to use lobby start in party
      if (goTopBtn && !goTopBtn.hasAttribute('disabled')) {
        const form = goTopBtn.closest('form');
        if (form) {
          form.addEventListener('submit', async (e) => {
            try {
              const r = await fetch('/api/lobby/status?mode=ranked');
              const j = await r.json().catch(() => null);
              const partyLen = (j && j.ok && Array.isArray(j.party)) ? j.party.length : 1;
              if (partyLen > 1) {
                e.preventDefault();
                const selectedPlayers = playersInput ? Math.max(1, Math.min(5, parseInt(playersInput.value || '1', 10) || 1)) : undefined;
                const rs = await fetch('/api/lobby/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mode: 'ranked', players: selectedPlayers }) });
                const sr = await rs.json().catch(() => null);
                if (sr && sr.ok && sr.redirect_url) {
                  location.href = sr.redirect_url;
                }
                return;
              }
            } catch (_) { /* fall through to normal submit */ }
          });
        }
      }
      fetchStatus();
    })();

    const inviteAddBtn = document.getElementById('invite-add-btn');
    const inviteMsg = document.getElementById('invite-msg');
    if (inviteAddBtn) {
      inviteAddBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        const code = prompt('Invite player by user ID code (e.g., ABC234):');
        if (!code) return;
        try {
          const r = await fetch('/api/invites/create', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ user_code: code, mode: 'ranked' }) });
          const j = await r.json().catch(() => null);
          if (j && j.ok) {
            if (inviteMsg) {
              inviteMsg.textContent = 'Invite sent. Expires in 5 minutes.';
              setTimeout(() => { inviteMsg.textContent = ''; }, 5000);
            }
          } else {
            const err = j && j.error ? j.error : 'failed';
            if (inviteMsg) inviteMsg.textContent = 'Invite ' + err + '.';
          }
        } catch (_) {
          if (inviteMsg) inviteMsg.textContent = 'Network error sending invite.';
        }
      });
    }

    const giveUpBtn = document.getElementById('give-up-btn');
    const solutionModal = document.getElementById('solution-modal');
    const solutionSteps = document.getElementById('solution-steps');
    const solutionInitial = document.getElementById('solution-initial');
    const solutionModalClose = document.getElementById('solution-modal-close');
    const giveUpChoiceModal = document.getElementById('giveup-choice-modal');
    const giveUpChoiceClose = document.getElementById('giveup-choice-close');
    const tryAgainBtn = document.getElementById('try-again-btn');
    const showSolutionBtn = document.getElementById('show-solution-btn');
    if (solutionModalClose && solutionModal) {
      solutionModalClose.addEventListener('click', () => {
        solutionModal.style.display = 'none';
        try { window.__SESSION_POLL_PAUSED__ = false; } catch (_) {}
        location.href = '/play';
      });
    }
    if (giveUpBtn) {
      giveUpBtn.addEventListener('click', (e) => {
        e.preventDefault();
        if (giveUpChoiceModal) giveUpChoiceModal.style.display = 'block';
      });
    }
    if (giveUpChoiceClose && giveUpChoiceModal) {
      giveUpChoiceClose.addEventListener('click', () => {
        giveUpChoiceModal.style.display = 'none';
      });
    }
    if (tryAgainBtn) {
      tryAgainBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        try {
          const sessionIdInput = document.querySelector('input[name="session_id"]');
          const sessionId = sessionIdInput ? Number(sessionIdInput.value) : null;
          if (!sessionId) return;
          const r = await fetch('/play/try_again', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ session_id: sessionId }) });
          const j = await r.json().catch(() => null);
          if (j && j.ok && j.redirect_url) {
            location.href = j.redirect_url;
          }
        } catch (_) {}
      });
    }
    if (showSolutionBtn) {
      showSolutionBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        try {
          const sessionIdInput = document.querySelector('input[name="session_id"]');
          const sessionId = sessionIdInput ? Number(sessionIdInput.value) : null;
          if (!sessionId) return;
          if (solutionSteps) solutionSteps.innerHTML = '<p>Loading stepsâ€¦</p>';
          const r = await fetch('/play/give_up', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ session_id: sessionId }) });
          const j = await r.json().catch(() => null);
          if (j && j.ok) {
            const steps = Array.isArray(j.steps) ? j.steps : [];
            const layout = j.layout || null;
            if (solutionInitial) {
              if (layout && layout.rows && layout.row_reserves && layout.col_reserves) {
                const rows = layout.rows;
                const row_res = layout.row_reserves;
                const col_res = layout.col_reserves;
                const opp = layout.opponent_row_index;
                const container = document.createElement('div');
                const title = document.createElement('div');
                title.innerHTML = '<strong>Initial Setup</strong>';
                title.style.marginBottom = '6px';
                container.appendChild(title);
                const grid = document.createElement('div');
                grid.className = 'grid';
                {
                  const row = document.createElement('div'); row.className = 'row';
                  let cell = document.createElement('div'); cell.className = 'cell reserve empty'; row.appendChild(cell);
                  cell = document.createElement('div'); cell.className = 'cell reserve empty'; row.appendChild(cell);
                  for (let c = 0; c < 5; c++) { const d = document.createElement('div'); d.className = 'cell reserve'; d.textContent = String(col_res[c][1] ?? ''); if (!d.textContent) d.classList.add('empty'); row.appendChild(d); }
                  grid.appendChild(row);
                }
                {
                  const row = document.createElement('div'); row.className = 'row';
                  let cell = document.createElement('div'); cell.className = 'cell reserve empty'; row.appendChild(cell);
                  cell = document.createElement('div'); cell.className = 'cell reserve empty'; row.appendChild(cell);
                  for (let c = 0; c < 5; c++) { const d = document.createElement('div'); d.className = 'cell reserve'; d.textContent = String(col_res[c][0] ?? ''); if (!d.textContent) d.classList.add('empty'); row.appendChild(d); }
                  grid.appendChild(row);
                }
                for (let rr = 0; rr < rows.length; rr++) {
                  const row = document.createElement('div'); row.className = 'row';
                  const resBot = document.createElement('div'); resBot.className = 'cell reserve'; resBot.textContent = String(row_res[rr][1] ?? ''); row.appendChild(resBot);
                  const resTop = document.createElement('div'); resTop.className = 'cell reserve'; resTop.textContent = String(row_res[rr][0] ?? ''); row.appendChild(resTop);
                  for (let cc = 0; cc < 5; cc++) {
                    const d = document.createElement('div'); d.className = 'cell' + (rr === opp ? ' opponent' : ''); d.textContent = String(rows[rr][cc] ?? ''); row.appendChild(d);
                  }
                  grid.appendChild(row);
                }
                solutionInitial.innerHTML = '';
                solutionInitial.appendChild(title);
                solutionInitial.appendChild(grid);
              } else {
                solutionInitial.innerHTML = '';
              }
            }
            if (solutionSteps) {
              if (steps.length > 0) {
                const ol = document.createElement('ol');
                steps.forEach((s) => { const li = document.createElement('li'); li.textContent = s; ol.appendChild(li); });
                solutionSteps.innerHTML = '';
                solutionSteps.appendChild(ol);
              } else {
                solutionSteps.innerHTML = '<p>No steps available.</p>';
              }
            }
            if (giveUpChoiceModal) giveUpChoiceModal.style.display = 'none';
            if (solutionModal) { window.__SESSION_POLL_PAUSED__ = true; solutionModal.style.display = 'block'; }
          }
        } catch (_) {}
      });
    }
  </script>
{% endblock %}


